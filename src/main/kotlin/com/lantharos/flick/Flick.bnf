{
  parserClass="com.lantharos.flick.parser.FlickParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Flick"
  psiImplClassSuffix="Impl"
  psiPackage="com.lantharos.flick.psi"
  psiImplPackage="com.lantharos.flick.psi.impl"

  elementTypeHolderClass="com.lantharos.flick.psi.FlickTypes"
  elementTypeClass="com.lantharos.flick.psi.FlickElementType"
  tokenTypeClass="com.lantharos.flick.psi.FlickTokenType"

  tokens=[
    // Keywords
    GROUP='group'
    BLUEPRINT='blueprint'
    TASK='task'
    FREE='free'
    LOCK='lock'
    ASSUME='assume'
    MAYBE='maybe'
    OTHERWISE='otherwise'
    EACH='each'
    MARCH='march'
    SUPPOSE='suppose'
    DO='do'
    FOR='for'
    WITH='with'
    IN='in'
    FROM='from'
    TO='to'
    WHEN='when'
    SELECT='select'
    END='end'
    PRINT='print'
    ASK='ask'
    AND='and'
    YES='yes'
    NO='no'
    NUM='num'
    LITERAL='literal'
    DECLARE='declare'
    USE='use'
    IMPORT='import'
    GIVE='give'
    ROUTE='route'
    RESPOND='respond'

    // HTTP Methods
    GET='GET'
    POST='POST'
    PUT='PUT'
    DELETE='DELETE'
    PATCH='PATCH'

    // Special identifiers (for web plugin)
    QUERY='query'
    BODY='body'
    HEADERS='headers'

    // Operators
    ASSIGN_OP=':='
    ASSIGN='='
    ARROW='=>'
    ARROW_DASH='->'
    EQ='=='
    NEQ='!='
    LT='<'
    GT='>'
    LTE='<='
    GTE='>='
    PLUS='+'
    MINUS='-'
    MULT='*'
    DIV='/'

    // Delimiters
    LPAREN='('
    RPAREN=')'
    LBRACE='{'
    RBRACE='}'
    LBRACKET='['
    RBRACKET=']'
    COMMA=','
    COLON=':'
    DOT='.'
    AT='@'

    // Literals
    STRING='regexp:"([^"\\]|\\.)*"|' + "'([^'\\]|\\.)*'"
    NUMBER='regexp:\d+(\.\d+)?'
    IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    COMMENT='regexp:#[^\n]*'
    WHITE_SPACE='regexp:\s+'
  ]
}

// Root rule
file ::= topLevelStatement*

topLevelStatement ::= declareStatement
                    | importStatement
                    | useStatement
                    | groupDeclaration
                    | blueprintDeclaration
                    | doImplementation
                    | taskDeclaration
                    | variableDeclaration
                    | routeStatement
                    | statement

statement ::= assignmentStatement
            | printStatement
            | ifStatement
            | eachLoop
            | marchLoop
            | selectStatement
            | returnStatement
            | respondStatement
            | expressionStatement


declareStatement ::= DECLARE IDENTIFIER (AT (NUMBER | IDENTIFIER))? { pin=1 }

importStatement ::= IMPORT (MULT | LBRACE importList RBRACE | IDENTIFIER) FROM STRING { pin=1 }

importList ::= IDENTIFIER (COMMA IDENTIFIER)*

useStatement ::= USE IDENTIFIER STRING? { pin=1 }

groupDeclaration ::= GROUP IDENTIFIER LBRACE groupBody* RBRACE { pin=1 }

groupBody ::= variableDeclaration | taskDeclaration

blueprintDeclaration ::= BLUEPRINT IDENTIFIER LBRACE blueprintBody* RBRACE { pin=1 }

blueprintBody ::= TASK IDENTIFIER (WITH parameterList)?

doImplementation ::= DO IDENTIFIER FOR IDENTIFIER ARROW taskDeclaration* END { pin=1 }

taskDeclaration ::= TASK taskName (WITH parameterList)? ARROW statement* END { pin=1 }

taskName ::= IDENTIFIER {
  mixin="com.lantharos.flick.psi.impl.FlickNamedElementImpl"
  implements="com.lantharos.flick.psi.FlickNamedElement"
}

parameterList ::= parameter (COMMA parameter)*

parameter ::= (NUM | LITERAL | IDENTIFIER) LPAREN parameterName RPAREN

parameterName ::= IDENTIFIER {
  mixin="com.lantharos.flick.psi.impl.FlickNamedElementImpl"
  implements="com.lantharos.flick.psi.FlickNamedElement"
}

variableDeclaration ::= (FREE | LOCK) typeAnnotation? variableName assignmentOp expression { pin=1 }

typeAnnotation ::= (NUM | LITERAL | IDENTIFIER)

variableName ::= IDENTIFIER {
  mixin="com.lantharos.flick.psi.impl.FlickNamedElementImpl"
  implements="com.lantharos.flick.psi.FlickNamedElement"
}

assignmentOp ::= ASSIGN_OP | ASSIGN

assignmentStatement ::= (IDENTIFIER | memberExpression) assignmentOp expression { pin=2 }

routeStatement ::= ROUTE httpMethod? STRING (ARROW statement* END | ARROW_DASH IDENTIFIER) { pin=1 }

httpMethod ::= GET | POST | PUT | DELETE | PATCH

respondStatement ::= RESPOND (respondContent | respondOptions) { pin=1 }

respondContent ::= expression

respondOptions ::= IDENTIFIER ASSIGN expression (COMMA IDENTIFIER ASSIGN expression)*

printStatement ::= PRINT printExpression (AND printExpression)* { pin=1 }

printExpression ::= expression

ifStatement ::= ASSUME expression ARROW statement* (MAYBE expression ARROW statement*)* (OTHERWISE ARROW statement*)? END { pin=1 }

eachLoop ::= EACH IDENTIFIER IN expression ARROW statement* END { pin=1 }

marchLoop ::= MARCH IDENTIFIER FROM expression TO expression ARROW statement* END { pin=1 }

selectStatement ::= SELECT expression ARROW whenClause* END { pin=1 }

whenClause ::= WHEN (STRING | NUMBER) ARROW (SUPPOSE expression ARROW)? statement*

returnStatement ::= GIVE expression? { pin=1 }

expressionStatement ::= expression

// Expression hierarchy
expression ::= ternaryExpression

// Inline ternary: assume condition => value, otherwise => alternate
ternaryExpression ::= logicalExpression (COMMA OTHERWISE ARROW logicalExpression)?
                    | ASSUME logicalExpression ARROW logicalExpression (COMMA OTHERWISE ARROW ternaryExpression)?

logicalExpression ::= equalityExpression (AND equalityExpression)*

equalityExpression ::= relationalExpression ((EQ | NEQ) relationalExpression)*

relationalExpression ::= additiveExpression ((LT | GT | LTE | GTE) additiveExpression)*

additiveExpression ::= multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)*

multiplicativeExpression ::= unaryExpression ((MULT | DIV) unaryExpression)*

unaryExpression ::= MINUS unaryExpression | postfixExpression

postfixExpression ::= primaryExpression (memberAccessor | callSuffix)*

memberAccessor ::= (DOT | DIV) IDENTIFIER
                 | LBRACKET expression RBRACKET

callSuffix ::= LPAREN argumentList? RPAREN

primaryExpression ::= literalExpression
                    | askExpression
                    | arrayLiteral
                    | objectLiteral
                    | LPAREN expression RPAREN
                    | variableReference

variableReference ::= IDENTIFIER {
  mixin="com.lantharos.flick.psi.impl.FlickReferenceElementImpl"
  implements="com.lantharos.flick.psi.FlickReferenceElement"
}

memberExpression ::= variableReference memberAccessor+

arrayLiteral ::= LBRACKET argumentList? RBRACKET

objectLiteral ::= LBRACE propertyList? RBRACE

propertyList ::= property (COMMA property)*

property ::= propertyKey COLON expression

propertyKey ::= STRING | IDENTIFIER

askExpression ::= ASK expression?

argumentList ::= expression (COMMA expression)*

literalExpression ::= STRING | NUMBER | YES | NO